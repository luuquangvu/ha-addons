name: Auto bump Home Assistant add-ons on upstream :latest

on:
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  check-bump-push:
    name: Bump ${{ matrix.addon.name }}
    runs-on: ubuntu-latest
    concurrency:
      group: auto-bump-${{ matrix.addon.name }}
      cancel-in-progress: false
    strategy:
      fail-fast: false
      matrix:
        addon:
          - name: gemini-fastapi
            dir: gemini-fastapi
            dockerfile: gemini-fastapi/Dockerfile
            digest_file: .github/upstream-gemini-fastapi.digest
    env:
      ADDON_DIR: ${{ matrix.addon.dir }}
      DOCKERFILE: ${{ matrix.addon.dockerfile }}
      DIGEST_FILE: ${{ matrix.addon.digest_file }}

    steps:
      - name: Checkout main
        uses: actions/checkout@v6

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.x"

      - name: Install Python dependencies
        run: pip install PyYAML

      - name: Extract upstream ref and resolve digest
        id: resolve
        run: |
          # Extract the FROM image
          REF=$(grep -m 1 '^FROM' "${DOCKERFILE}" | awk '{print $2}')
          if [ -z "$REF" ]; then
            echo "::error::Cannot find FROM line in ${DOCKERFILE}"
            exit 1
          fi
          echo "Upstream ref: $REF"
          echo "ref=$REF" >> "$GITHUB_OUTPUT"

          # Resolve remote digest
          INFO=$(skopeo inspect "docker://$REF")
          DIGEST=$(echo "$INFO" | jq -r '.Digest')

          if [ -z "$DIGEST" ] || [ "$DIGEST" = "null" ]; then
            echo "::error::Failed to resolve digest for $REF"
            exit 1
          fi
          echo "Latest digest: $DIGEST"
          echo "latest_digest=$DIGEST" >> "$GITHUB_OUTPUT"

          # Check against previous digest
          if [ -f "${DIGEST_FILE}" ]; then
            PREV=$(cat "${DIGEST_FILE}")
          else
            PREV=""
          fi
          echo "Previous digest: ${PREV:-<none>}"

          if [ "$PREV" = "$DIGEST" ]; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
            echo "Digest unchanged."
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "Digest changed! Proceeding to validation."
          fi

      - name: Validate Architectures and Bump Version
        if: steps.resolve.outputs.changed == 'true'
        env:
          UPSTREAM_REF: ${{ steps.resolve.outputs.ref }}
          LATEST_DIGEST: ${{ steps.resolve.outputs.latest_digest }}
        run: |
          # Export manifest to env var for safe Python consumption
          export RAW_MANIFEST=$(skopeo inspect --raw "docker://${UPSTREAM_REF}")

          # Pass manifest to Python for complex validation & bumping
          python - <<EOF
          import os
          import json
          import pathlib
          import re
          import sys
          import yaml
          from datetime import date

          # Load config
          addon_dir = pathlib.Path(os.environ["ADDON_DIR"])
          config_path = addon_dir / "config.yaml"
          digest_file = pathlib.Path(os.environ["DIGEST_FILE"])

          with open(config_path, "r", encoding="utf-8") as f:
              data = yaml.safe_load(f)

          # 1. Validate Architectures
          # Map HA arch to Docker platform (os/arch)
          ha_arch_map = {
              "amd64": "linux/amd64",
              "aarch64": "linux/arm64"
          }

          required_archs = data.get("arch", [])
          required_platforms = [ha_arch_map[a] for a in required_archs if a in ha_arch_map]

          # Load manifest from env var
          raw_manifest_str = os.environ.get("RAW_MANIFEST", "{}")
          raw_manifest = json.loads(raw_manifest_str)

          available_platforms = set()
          if "manifests" in raw_manifest:
              for m in raw_manifest["manifests"]:
                  p = m["platform"]
                  available_platforms.add(f"{p['os']}/{p['architecture']}")
                  # Handle variant if present (e.g. arm/v7)
                  if "variant" in p:
                       available_platforms.add(f"{p['os']}/{p['architecture']}/{p['variant']}")
          else:
              # Single image manifest
              os_name = raw_manifest.get("os", raw_manifest.get("Os", "linux"))
              arch = raw_manifest.get("architecture", raw_manifest.get("Architecture", "amd64"))
              available_platforms.add(f"{os_name}/{arch}")

          print(f"Required: {required_platforms}")
          print(f"Available: {available_platforms}")

          missing = [p for p in required_platforms if p not in available_platforms]
          if missing:
              print(f"::error::Upstream lacks required platforms: {missing}")
              sys.exit(1)

          print("Architecture check passed.")

          # 2. Bump Version
          ver = str(data.get("version", "0.0.0"))
          m = re.match(r"^(\d+)\.(\d+)\.(\d+)$", ver)
          if not m:
              print(f"::error::Unsupported version format: {ver}")
              sys.exit(1)

          major, minor, patch = map(int, m.groups())
          new_ver = f"{major}.{minor}.{patch + 1}"
          data["version"] = new_ver

          with open(config_path, "w", encoding="utf-8") as f:
              yaml.safe_dump(data, f, sort_keys=False, allow_unicode=True)

          print(f"Bumped version from {ver} to {new_ver}")

          # 3. Update Digest File
          digest_file.parent.mkdir(parents=True, exist_ok=True)
          digest_file.write_text(os.environ["LATEST_DIGEST"], encoding="utf-8")

          # 4. Update CHANGELOG.md
          changelog_path = addon_dir / "CHANGELOG.md"
          old_content = ""
          if changelog_path.exists():
              old_content = changelog_path.read_text(encoding="utf-8")

          today = date.today().isoformat()

          digest_short = (
            f"{os.environ['LATEST_DIGEST'][:19]}..." if "LATEST_DIGEST" in os.environ else "latest"
          )

          new_entry = f"## {new_ver} - {today}\n\n- Update upstream image to {digest_short}\n\n"

          if "# Changelog" in old_content:
              parts = old_content.split("\n", 1)
              header = parts[0]
              rest = parts[1] if len(parts) > 1 else ""
              if rest.startswith("\n"):
                  rest = rest[1:]
              final_content = f"{header}\n\n{new_entry}{rest}"
          else:
              final_content = f"# Changelog\n\n{new_entry}{old_content}"

          changelog_path.write_text(final_content, encoding="utf-8")
          print(f"Updated CHANGELOG.md with version {new_ver}")

          EOF

      - name: Lint Home Assistant add-on
        if: steps.resolve.outputs.changed == 'true'
        uses: frenck/action-addon-linter@v2
        with:
          path: ${{ env.ADDON_DIR }}

      - name: Commit and push
        if: steps.resolve.outputs.changed == 'true'
        run: |
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"

          git add "${ADDON_DIR}/config.yaml" "${DIGEST_FILE}" "${ADDON_DIR}/CHANGELOG.md"

          # Safety check: see if anything is actually staged
          if git diff --staged --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          MSG="chore(${{ matrix.addon.name }}): bump version (upstream ${{ steps.resolve.outputs.ref }} -> ${{ steps.resolve.outputs.latest_digest }})"
          git commit -m "$MSG"

          # Pull rebase to handle concurrency
          git pull --rebase origin main
          git push origin HEAD:main
